/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/battle.js":
/*!***********************!*\
  !*** ./src/battle.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: () => (/* binding */ Player),\n/* harmony export */   Ship: () => (/* binding */ Ship)\n/* harmony export */ });\nclass Ship {\n    constructor(x1, y1, x2, y2) {\n        this.hitCounter = 0;\n        this.x1 = x1;\n        this.x2 = x2;\n        this.y1 = y1;\n        this.y2 = y2;\n        this.size = Math.max(y2 - y1, x2 - x1) + 1;\n    }\n    getSize() {\n        return this.size;\n    }\n    getHitCounter(){\n        return this.hitCounter;\n    }\n    hit() {\n        this.hitCounter += 1;\n    }\n\n    isSunk() {\n        return this.hitCounter === this.size;\n    }\n\n    coordinateArray() {\n        let arr = [];\n        for (let i = 0; i < this.size; i++) {\n            if (this.y2 - this.y1 > this.x2 - this.x1) {\n                arr.push([this.x2, this.y1 + i]);\n            } else {\n                arr.push([this.x1 + i, this.y2]);\n            }\n        }\n        return arr;\n    }\n}\n\nclass Gameboard {\n    constructor() {\n        this.attackList = [];\n        this.shipList = [];\n        \n        let carrier = new Ship(1, 1, 5, 1);\n        let battleship = new Ship(1, 2, 1, 5);\n        let destroyer = new Ship(6, 5, 8, 5);\n        let submarine = new Ship(7, 8, 7, 10);\n        let patrol = new Ship(1, 9, 1, 10);\n\n        this.carrier = carrier;\n        this.battleship = battleship;\n        this.destroyer = destroyer;\n        this.submarine = submarine;\n        this.patrol = patrol;\n\n        this.shipList.push(carrier);\n        this.shipList.push(battleship);\n        this.shipList.push(destroyer);\n        this.shipList.push(submarine);\n        this.shipList.push(patrol);\n\n\n    }\n\n\n    recieveAttack(x, y){\n        this.attackList.push([x,y]);\n        for(const ship of this.shipList) {\n            let coordinates = ship.coordinateArray();\n            // console.log(coordinates);\n            // console.log(`hitCounter: ${ship.getHitCounter()}`)\n            if(coordinates.some(pair => pair[0] == x && pair[1] == y)){\n                ship.hit();\n                return true\n            }\n            \n        }\n\n            return false\n    }\n \n    allSink(){\n        let counter = 0;\n        for(const ship of this.shipList){\n            console.log(`counter: ${counter} `);\n            console.log(`hitCounter: ${ship.getHitCounter()}`)\n            if(ship.isSunk()){\n                counter += 1;\n                console.log(`Ship: ${ship}`);\n            }\n        }\n\n        if(counter == 5){\n            return true;\n        }\n        else{\n            return false;\n        }\n\n\n    }\n\n    getCoordinateList(){\n        let coordinateList = []\n        for(const ship of this.shipList){\n            // console.log(`ship.coordinateArray: ${ship.coordinateArray()}`);\n            coordinateList = [...coordinateList, ...ship.coordinateArray()]\n        }\n        return coordinateList;\n    }\n\n    getAttackList(){\n        return this.attackList;\n    }\n\n\n}\n\nclass Player{\n    constructor(){\n        let gameboard = new Gameboard();\n        this.gameboard = gameboard;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmF0dGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDLHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmF0dGxlc2hpcC8uL3NyYy9iYXR0bGUuanM/NTBmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTaGlwIHtcbiAgICBjb25zdHJ1Y3Rvcih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB0aGlzLmhpdENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLngxID0geDE7XG4gICAgICAgIHRoaXMueDIgPSB4MjtcbiAgICAgICAgdGhpcy55MSA9IHkxO1xuICAgICAgICB0aGlzLnkyID0geTI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KHkyIC0geTEsIHgyIC0geDEpICsgMTtcbiAgICB9XG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0SGl0Q291bnRlcigpe1xuICAgICAgICByZXR1cm4gdGhpcy5oaXRDb3VudGVyO1xuICAgIH1cbiAgICBoaXQoKSB7XG4gICAgICAgIHRoaXMuaGl0Q291bnRlciArPSAxO1xuICAgIH1cblxuICAgIGlzU3VuaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGl0Q291bnRlciA9PT0gdGhpcy5zaXplO1xuICAgIH1cblxuICAgIGNvb3JkaW5hdGVBcnJheSgpIHtcbiAgICAgICAgbGV0IGFyciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy55MiAtIHRoaXMueTEgPiB0aGlzLngyIC0gdGhpcy54MSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFt0aGlzLngyLCB0aGlzLnkxICsgaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbdGhpcy54MSArIGksIHRoaXMueTJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cblxuY2xhc3MgR2FtZWJvYXJkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hdHRhY2tMaXN0ID0gW107XG4gICAgICAgIHRoaXMuc2hpcExpc3QgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGxldCBjYXJyaWVyID0gbmV3IFNoaXAoMSwgMSwgNSwgMSk7XG4gICAgICAgIGxldCBiYXR0bGVzaGlwID0gbmV3IFNoaXAoMSwgMiwgMSwgNSk7XG4gICAgICAgIGxldCBkZXN0cm95ZXIgPSBuZXcgU2hpcCg2LCA1LCA4LCA1KTtcbiAgICAgICAgbGV0IHN1Ym1hcmluZSA9IG5ldyBTaGlwKDcsIDgsIDcsIDEwKTtcbiAgICAgICAgbGV0IHBhdHJvbCA9IG5ldyBTaGlwKDEsIDksIDEsIDEwKTtcblxuICAgICAgICB0aGlzLmNhcnJpZXIgPSBjYXJyaWVyO1xuICAgICAgICB0aGlzLmJhdHRsZXNoaXAgPSBiYXR0bGVzaGlwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llciA9IGRlc3Ryb3llcjtcbiAgICAgICAgdGhpcy5zdWJtYXJpbmUgPSBzdWJtYXJpbmU7XG4gICAgICAgIHRoaXMucGF0cm9sID0gcGF0cm9sO1xuXG4gICAgICAgIHRoaXMuc2hpcExpc3QucHVzaChjYXJyaWVyKTtcbiAgICAgICAgdGhpcy5zaGlwTGlzdC5wdXNoKGJhdHRsZXNoaXApO1xuICAgICAgICB0aGlzLnNoaXBMaXN0LnB1c2goZGVzdHJveWVyKTtcbiAgICAgICAgdGhpcy5zaGlwTGlzdC5wdXNoKHN1Ym1hcmluZSk7XG4gICAgICAgIHRoaXMuc2hpcExpc3QucHVzaChwYXRyb2wpO1xuXG5cbiAgICB9XG5cblxuICAgIHJlY2lldmVBdHRhY2soeCwgeSl7XG4gICAgICAgIHRoaXMuYXR0YWNrTGlzdC5wdXNoKFt4LHldKTtcbiAgICAgICAgZm9yKGNvbnN0IHNoaXAgb2YgdGhpcy5zaGlwTGlzdCkge1xuICAgICAgICAgICAgbGV0IGNvb3JkaW5hdGVzID0gc2hpcC5jb29yZGluYXRlQXJyYXkoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBoaXRDb3VudGVyOiAke3NoaXAuZ2V0SGl0Q291bnRlcigpfWApXG4gICAgICAgICAgICBpZihjb29yZGluYXRlcy5zb21lKHBhaXIgPT4gcGFpclswXSA9PSB4ICYmIHBhaXJbMV0gPT0geSkpe1xuICAgICAgICAgICAgICAgIHNoaXAuaGl0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiBcbiAgICBhbGxTaW5rKCl7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgZm9yKGNvbnN0IHNoaXAgb2YgdGhpcy5zaGlwTGlzdCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgY291bnRlcjogJHtjb3VudGVyfSBgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBoaXRDb3VudGVyOiAke3NoaXAuZ2V0SGl0Q291bnRlcigpfWApXG4gICAgICAgICAgICBpZihzaGlwLmlzU3VuaygpKXtcbiAgICAgICAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFNoaXA6ICR7c2hpcH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNvdW50ZXIgPT0gNSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIGdldENvb3JkaW5hdGVMaXN0KCl7XG4gICAgICAgIGxldCBjb29yZGluYXRlTGlzdCA9IFtdXG4gICAgICAgIGZvcihjb25zdCBzaGlwIG9mIHRoaXMuc2hpcExpc3Qpe1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYHNoaXAuY29vcmRpbmF0ZUFycmF5OiAke3NoaXAuY29vcmRpbmF0ZUFycmF5KCl9YCk7XG4gICAgICAgICAgICBjb29yZGluYXRlTGlzdCA9IFsuLi5jb29yZGluYXRlTGlzdCwgLi4uc2hpcC5jb29yZGluYXRlQXJyYXkoKV1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZUxpc3Q7XG4gICAgfVxuXG4gICAgZ2V0QXR0YWNrTGlzdCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2tMaXN0O1xuICAgIH1cblxuXG59XG5cbmNsYXNzIFBsYXllcntcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBsZXQgZ2FtZWJvYXJkID0gbmV3IEdhbWVib2FyZCgpO1xuICAgICAgICB0aGlzLmdhbWVib2FyZCA9IGdhbWVib2FyZDtcbiAgICB9XG59XG5cbmV4cG9ydCB7UGxheWVyLCBTaGlwfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/battle.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _battle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./battle.js */ \"./src/battle.js\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n\nlet playerOne = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Player();\nlet playerTwo = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Player();\n\nlet currentHighlight;\nlet currentSize = 1;\nlet currentDirection;\nlet placeAllowed;\nlet placeLocation;\nlet shipNames = [\"Carrier\", \"Battleship\", \"Destroyer\", \"Submarine\" ,\"Patrol\"]\n\nconst leftSide = document.getElementById(\"left_side\");\nconst rightSide = document.getElementById(\"right_side\");\nlet announcement = document.getElementById(\"announcement\");\n\nannouncement.textContent = \"Arrange your ships!\"\n\n\nfullyRenderSide(leftSide, playerOne);\nfullyRenderSide(rightSide, playerTwo);\n\nlet currentId;\n\n\nfunction addGridBoxes(side,coords){\n    \n    for(let i = 1; i <= 10; i++){\n        for(let j = 1; j <= 10; j++){\n            if(checkPair(i,j,coords) == false){\n                let gridBox = document.createElement(\"div\");\n                gridBox.classList.add(\"gridBox\");\n                gridBox.setAttribute(\"horizontal\", `${i}`);\n                gridBox.setAttribute(\"vertical\", `${j}`);\n                if(side.id == \"left_side\"){\n                    gridBox.id = `Lsquare${(i-1)* 10 + (j)}`\n                }\n                else{\n                        gridBox.id = `Rsquare${(i-1)* 10 + (j)}`\n                }\n                \n                gridBox.vertical = j;\n            \n                side.appendChild(gridBox);\n            }\n            \n            \n        }\n    }\n}\n\nfunction fullyRenderSide(side, player){\n    side.innerHTML = \"\";\n    let shipCoordinates = player.gameboard.getCoordinateList();\n    \n\n    let restrictedSquares = makeRestrictedSquaresList(shipCoordinates);\n    addGridBoxes(side,shipCoordinates)\n    renderGrid(side, player, restrictedSquares)\n}\n\n\nfunction checkPair(x,y, shipCoordinates){\n    for(const pair of shipCoordinates){\n        if(pair[0] == x && pair[1] == y){\n            return true;\n        }\n        \n    }\n    return false;\n}\n\nfunction makeRestrictedSquaresList(coordList){\n\n    let restrictedSquares = [];\n    for(const pair of coordList){\n        let x = parseInt(pair[0]);\n        let y = parseInt(pair[1]);\n\n        let squareNum = (x-1)*10 + y;\n        restrictedSquares.push(squareNum);\n\n    }\n    return restrictedSquares;\n\n    // console.log(restrictedSquares);\n\n    // console.log()\n}\nfunction clearSquares(){\n    let allSquares = document.querySelectorAll(\".gridBox\");\n    allSquares.forEach((square) => {\n        square.style.backgroundColor = \"white\";\n    })\n}\n\nfunction checkCollision(squareNum, horizontal, restrictedSquares){\n    let square = document.getElementById(squareNum);\n    \n    \n    console.log(`squareNum in collision: ${squareNum}`);\n    for(let i = 0; i < currentSize; i++){\n        // console.log(`squareNum+i: ${squareNum+i}`);\n        // console.log(`currentSize in collision: ${currentSize}`)\n\n        if (horizontal === \"true\"){\n            if(restrictedSquares.includes(squareNum+i)){\n                return true;\n            }\n        }\n        else{\n            if(restrictedSquares.includes(squareNum+i*10)){\n                return true;\n            }\n        }\n        \n    }\n\n    return false\n    \n\n    \n}\nfunction renderGrid(side, player, restrictedSquares){\n    const shipList = player.gameboard.shipList;\n    let counter = 0;\n    let colorList = [\"gray\", \"blue\", \"orange\", \"red\", \"yellow\"];\n    \n    \n    let sideText;\n    if(side.id == \"left_side\"){\n        sideText = \"L\";\n    }\n    else{\n        sideText = \"R\"\n    }\n    side.addEventListener(\"dragover\", (e) => {\n        \n        e.preventDefault(); // Allow drop\n        \n        \n        let dragShip = document.getElementById(currentId);\n        \n        let shipSize = dragShip.getAttribute(\"size\");\n\n        let horizontal = dragShip.getAttribute(\"horizontal\");\n\n        \n        currentSize = parseInt(dragShip.getAttribute(\"size\"));\n\n\n\n        let previousSquare;\n\n        if(currentHighlight){\n            previousSquare = document.getElementById(currentHighlight);\n            if(e.target.id != previousSquare){\n                \n                clearSquares();\n\n            }\n        }\n        \n        \n        let targetId = e.target.id;\n\n        console.log(`dragShip.id: ${dragShip.id} e.target.id[0]${e.target.id[0]}`);\n        if (dragShip.id[0] != e.target.id[0]) {\n            placeAllowed = false;\n            return;\n             // Skip processing for elements not within this side\n        }\n\n        if((side.contains(e.target)) && !e.target.hasAttribute(\"size\")){\n            currentHighlight = e.target.id;\n            let squareNum = parseInt(e.target.id.match(/\\d+/)[0])\n            console.log(`e.target.id: ${e.target.id}`);\n            \n\n            //horizontal checking\n            \n            if(horizontal === \"true\"){\n                if(((parseInt(squareNum) -1 )% 10) + parseInt(currentSize) > 10){\n                \n                    for(let i = squareNum; i <= parseInt((squareNum-1)/10)*10 + 10; i++ ){\n                        \n                        let square = document.getElementById(`${sideText}square${parseInt(i) }`);\n                        square.style.backgroundColor = \"red\";\n                        placeAllowed = false;\n                        placeLocation = squareNum;\n                    }\n                }\n                //no collision and no overflow\n                else{\n                    console.log(`collision: ${checkCollision(squareNum, horizontal, restrictedSquares)}`)\n                    if(!checkCollision(squareNum, horizontal, restrictedSquares)){\n                        for(let i = 0; i < currentSize; i++){\n                            let square = document.getElementById(`${sideText}square${parseInt(squareNum) + i }`);\n                            \n                    \n                            \n                        \n                            square.style.backgroundColor = \"green\";\n                            placeAllowed = true;\n                            placeLocation = squareNum;\n                            \n                        \n                    }\n                    }\n\n                    //collision check horizontal\n                    else{\n                        for(let i = 0; i < currentSize; i++){\n    \n                            if(!restrictedSquares.includes(squareNum+i)){\n                                let square = document.getElementById(`${sideText}square${parseInt(squareNum) + i }`);\n                                square.style.backgroundColor = \"red\";\n                                placeAllowed = false;\n                                placeLocation = squareNum;\n                            }     \n                                          \n                            \n                        \n                            }\n                    }\n                    \n                    \n                }\n            }\n\n            //vertical checking\n            else{\n\n                //check if overflow vertically\n                if((squareNum-10) + currentSize*10 > 100){\n                    console.log(`squareNum + currentSize*10:${squareNum + currentSize*10}`)\n                    \n                    for(let i = squareNum; i <= 100; i+= 10 ){\n                        console.log(`squareNum + i: ${parseInt(i) }`)\n                        let square = document.getElementById(`${sideText}square${parseInt(i) }`);\n                        console.log(`squaresecondId: ${square.id}`);\n                        square.style.backgroundColor = \"red\";\n                        placeAllowed = false;\n                        placeLocation = squareNum;\n                    }\n\n                    \n                }\n\n                //check for collision vertically\n                else{\n                    if(!checkCollision(squareNum, horizontal, restrictedSquares)){\n                        \n                        for(let i = 0; i < currentSize; i++){\n                            let square = document.getElementById(`${sideText}square${parseInt(squareNum) + i*10 }`);\n                            \n                    \n                            \n                        \n                            square.style.backgroundColor = \"green\";\n                            \n                            placeAllowed = true;\n                            placeLocation = squareNum;\n                        }\n                    }\n\n                    else{\n                        for(let i = 0; i < currentSize; i++){\n                            \n                            if(!restrictedSquares.includes(squareNum+i*10)){\n                                let square = document.getElementById(`${sideText}square${parseInt(squareNum) + i*10}`);\n                                square.style.backgroundColor = \"red\";\n                                placeLocation = squareNum;\n                                placeAllowed = false;\n                            }     \n                                          \n                            \n                        \n                            }\n                    }\n                }\n            }\n\n\n            \n\n        }\n        \n    })\n\n    side.addEventListener(\"click\", (e) => {\n        e.preventDefault();\n        console.log(e.target.getAttribute(\"horizontal\"));\n        console.log(e.target.getAttribute(\"vertical\"));\n        \n    })\n\n    let shipCounter = 0;\n    for(const ship of shipList){\n        let coordinateArray = ship.coordinateArray();\n        let coordLength = coordinateArray.length;\n        \n            let gridShip = document.createElement(\"div\");\n            gridShip.style.backgroundColor = colorList[counter];\n            gridShip.style.border = \"3px solid\"\n            gridShip.setAttribute(\"size\", ship.getSize());\n            gridShip.id = `${sideText+ shipNames[shipCounter]}`;\n            shipCounter += 1;\n            gridShip.setAttribute(\"index\", counter)\n            gridShip.setAttribute(\"draggable\", true);\n            //horizontal direction\n        \n            if(coordinateArray[0][0] == coordinateArray[1][0]){\n                gridShip.setAttribute(\"horizontal\", true);\n                \n                // console.log(\"first\");\n                gridShip.style.gridRow = `${coordinateArray[0][0]} / ${coordinateArray[0][0]}`;\n                gridShip.style.gridColumn = `${coordinateArray[0][1]} / ${coordinateArray[coordLength-1][1] + 1}`;\n            }\n            else{\n                gridShip.setAttribute(\"horizontal\", false);\n                gridShip.style.gridRow = `${coordinateArray[0][0]} / ${coordinateArray[coordLength-1][0] + 1}`;\n                gridShip.style.gridColumn = `${coordinateArray[0][1]} / ${coordinateArray[0][1]}`;\n                \n            }\n\n            //click to flip direction\n            gridShip.addEventListener(\"click\", (e) => {\n                let size = parseInt(gridShip.getAttribute(\"size\"))\n                let gridShipSquares = [];\n                for(const pair of coordinateArray){\n                    let x = parseInt(pair[0]);\n                    let y = parseInt(pair[1]);\n\n                    gridShipSquares.push((x-1)*10 + y );\n\n                }\n                console.log(`Restricted Squares: ${restrictedSquares}`)\n                console.log(`gridShipSquares: ${gridShipSquares}`)\n                console.log(`coordinateArray: ${coordinateArray}`)\n                \n                \n                let shipHorizontal = gridShip.getAttribute(\"horizontal\");\n\n                //flip to horizontal\n                if(shipHorizontal == \"false\"){\n                    console.log(\"vertical\");\n                    for(let i = 0; i < size; i++){\n                        \n                        let x = parseInt(coordinateArray[i][0]);\n                        let y = parseInt(coordinateArray[i][1]);\n                        let currentNum = (x-1) * 10 + y;\n                        let workingNum;\n                        console.log(`currentNum: ${currentNum}`)\n                        console.log(`y + size - 1: ${y + size - 1}`)\n                        let collision = false;\n\n                        //check if can flip to right\n                        if(y + size - 1 <= 10){\n                            console.log(\"no overflow to the right\")\n                            for(let j = 0; j < size; j++){\n                                if(!gridShipSquares.includes(currentNum + j)){\n                                    if(restrictedSquares.includes(currentNum + j)){\n                                        collision = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            if(!collision){\n                                let otherShip = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Ship(x,y,x,y+size-1);\n                                player.gameboard.shipList[parseInt(gridShip.getAttribute(\"index\"))] = otherShip;\n                        \n                                fullyRenderSide(side,player);\n                                console.log(\"got to the end\")\n                                break;\n                            }\n                        }\n\n                        //check left \n                        else if(y - (size - 1) > 0){\n                            console.log(\"no overflow to the left\")\n                            for(let j = 0; j < size; j++){\n                                if(!gridShipSquares.includes(currentNum - j)){\n                                    if(restrictedSquares.includes(currentNum - j)){\n                                        collision = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            if(!collision){\n                                let otherShip = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Ship(x,y - size+1,x,y);\n                                player.gameboard.shipList[parseInt(gridShip.getAttribute(\"index\"))] = otherShip;\n                        \n                                fullyRenderSide(side,player);\n                                console.log(\"got to the end\")\n                                break;\n                            }\n                        }\n                          \n                    }\n                }\n\n                //flip to vertical\n                else{\n                    console.log(\"horizontal\")\n                    for(let i = 0; i < size; i++){\n                        \n                        let x = parseInt(coordinateArray[i][0]);\n                        let y = parseInt(coordinateArray[i][1]);\n                        let currentNum = (x-1) * 10 + y;\n                        let workingNum;\n                        console.log(`currentNum: ${currentNum}`)\n                        console.log(`x - size: ${x - size}`)\n                        let collision = false;\n\n                        //check if can flip up\n                        if(x - size >= 0){\n                            console.log(\"no overflow up\")\n                            for(let j = 0; j < size; j++){\n                                console.log(`currentNum + j*10: ${currentNum + j*10}`)\n                                if(!gridShipSquares.includes(currentNum - j*10)){\n                                    if(restrictedSquares.includes(currentNum - j*10)){\n                                        collision = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            if(!collision){\n                                let otherShip = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Ship(x - size +1,y,x,y);\n                                player.gameboard.shipList[parseInt(gridShip.getAttribute(\"index\"))] = otherShip;\n                        \n                                fullyRenderSide(side,player);\n                                console.log(\"got to the end\")\n                                break;\n                            }\n                        }\n\n                        //check if can flip down\n                        else if(x + size <= 10){\n                            console.log(\"no overflow to the down\")\n                            for(let j = 0; j < size; j++){\n                                if(!gridShipSquares.includes(currentNum + j*10)){\n                                    if(restrictedSquares.includes(currentNum + j*10)){\n                                        collision = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            \n                            if(!collision){\n                                let otherShip = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Ship(x,y,x+size-1,y);\n                                player.gameboard.shipList[parseInt(gridShip.getAttribute(\"index\"))] = otherShip;\n                        \n                                fullyRenderSide(side,player);\n                                console.log(\"got to the end\")\n                                break;\n                            }\n                        }\n                          \n                    }\n                }\n            })\n            gridShip.addEventListener(\"dragstart\", (e) => {\n                currentId = e.target.id;\n                \n            })\n\n            \n            gridShip.addEventListener(\"dragend\", (e) => {\n                clearSquares();\n                console.log(`left at: ${e.target.id}`);\n                console.log(`lastLocation: ${placeLocation}`);\n                console.log(`allowed: ${placeAllowed}`)\n\n                if(placeAllowed){\n                    console.log(\"allowed true\")\n                    let ship = document.getElementById(e.target.id);\n                    \n                    let currentSquare = document.getElementById(`${sideText}square${placeLocation}`);\n                    let row = parseInt(currentSquare.getAttribute(\"horizontal\"));\n                    let column = parseInt(currentSquare.getAttribute(\"vertical\"));\n                    let horizontal = ship.getAttribute(\"horizontal\");\n\n                    \n                    \n                    let otherShip;\n        \n                    if(horizontal == \"true\"){\n                        otherShip = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Ship(row,column,row,column + currentSize -1);\n                    }\n                    else{\n                        otherShip = new _battle_js__WEBPACK_IMPORTED_MODULE_0__.Ship(row,column,row + currentSize -1,column);\n                    }\n                    \n\n                    \n                    player.gameboard.shipList[parseInt(ship.getAttribute(\"index\"))] = otherShip;\n                    \n                    fullyRenderSide(side,player);\n                    \n                        \n                        \n                    \n                }\n            })\n\n            side.appendChild(gridShip);\n\n            counter += 1;\n    }\n}\n\nlet leftButton = document.getElementById(\"left_button\");\nlet rightButton = document.getElementById(\"right_button\");\n\nlet leftReady = false;\nlet rightReady = false;\n\nlet startButton = document.getElementById(\"start_button\");\n\n\n\nleftButton.addEventListener(\"click\", () =>{\n    if(!leftReady){\n        leftSide.innerHTML = \"\";\n        leftSide.style.backgroundColor = \"gray\";\n        leftButton.style.backgroundColor = \"gray\";\n        leftReady = !leftReady;\n    }\n\n    else{\n        leftSide.style.backgroundColor = \"transparent\";\n        leftButton.style.backgroundColor = \"aqua\";\n        leftReady = !leftReady;\n        fullyRenderSide(leftSide, playerOne)\n    }\n\n    if(leftReady && rightReady){\n        startButton.style.display = \"inline\"\n    }\n    else{\n        startButton.style.display = \"none\"\n    }\n})\n\nrightButton.addEventListener(\"click\", () =>{\n    if(!rightReady){\n        rightSide.innerHTML = \"\";\n        rightSide.style.backgroundColor = \"gray\";\n        rightButton.style.backgroundColor = \"gray\";\n        rightReady = !rightReady;\n    }\n\n    else{\n        rightSide.style.backgroundColor = \"transparent\"\n        rightButton.style.backgroundColor = \"aqua\";\n        rightReady = !rightReady;\n        fullyRenderSide(rightSide, playerTwo)\n    }\n\n    if(leftReady && rightReady){\n        startButton.style.display = \"inline\"\n    }\n    else{\n        startButton.style.display = \"none\"\n    }\n})\n\n\nstartButton.addEventListener(\"click\", () => {\n    announcement.textContent = \"\";\n    const newLeft = leftSide.cloneNode(true);\n    leftSide.replaceWith(newLeft);\n\n    const newRight = rightSide.cloneNode(true);\n    rightSide.replaceWith(newRight);\n    newLeft.innerHTML = \"\";\n    newRight.innerHTML = \"\";\n\n    newLeft.style.backgroundColor = \"transparent\";\n    newRight.style.backgroundColor = \"transparent\";\n\n    leftButton.style.display = \"none\";\n    rightButton.style.display = \"none\";\n    startButton.style.display = \"none\";\n\n\n    addGridBoxes(newLeft, []);\n    addGridBoxes(newRight, []);\n\n\n    let leftTurn = true;\n    let rightTurn = false;\n\n    let playerText1 = document.getElementById(\"playerText1\");\n    let playerText2 = document.getElementById(\"playerText2\");\n\n    playerText1.classList.add(\"turn\");\n\n\n\n    newLeft.addEventListener(\"click\", (e) => {\n        if (rightTurn && e.target.classList.contains(\"gridBox\")){\n            e.preventDefault();\n            \n            let x = parseInt(e.target.getAttribute(\"horizontal\"));\n            let y = parseInt(e.target.getAttribute(\"vertical\"));\n            let attackList = playerOne.gameboard.attackList;\n            if(!checkPair(x,y,attackList)){\n        \n                leftTurn = !leftTurn;\n                rightTurn = !rightTurn;\n                \n                playerText2.classList.remove(\"turn\");\n                playerText1.classList.add(\"turn\");\n                let shipSunk;\n                \n                if(playerOne.gameboard.recieveAttack(x,y)){\n                    e.target.style.color = \"red\";\n                    e.target.style.borderColor = \"black\"\n                    \n                    for(const ship of playerOne.gameboard.shipList){\n                        let shipCoords = ship.coordinateArray();\n                        for(const pair of shipCoords){\n                            if(parseInt(pair[0]) == x && parseInt(pair[1]) == y){\n                                shipSunk = ship.isSunk();\n                            }\n                        }\n                        console.log(shipCoords);\n                    }\n                }\n\n                if(shipSunk){\n                    announcement.innerHTML = \"Ship Has Been Sunk!\"\n                    shipSunk = !shipSunk;\n                }\n\n                else{\n                    announcement.innerHTML = \"\";\n                }\n\n\n                e.target.innerHTML = \"X\";\n\n                if(playerOne.gameboard.allSink()){\n                    endGame(\"Player 2\");\n                }\n                console.log(e.target.getAttribute(\"horizontal\"));\n                console.log(e.target.getAttribute(\"vertical\"));\n            }\n            \n        }\n        \n    })\n    \n    newRight.addEventListener(\"click\", (e) => {\n        if (leftTurn && e.target.classList.contains(\"gridBox\")){\n            e.preventDefault();\n\n            \n            let x = parseInt(e.target.getAttribute(\"horizontal\"));\n            let y = parseInt(e.target.getAttribute(\"vertical\"));\n            let attackList = playerTwo.gameboard.attackList;\n            if(!checkPair(x,y,attackList)){\n        \n                leftTurn = !leftTurn;\n                rightTurn = !rightTurn;\n\n                playerText1.classList.remove(\"turn\");\n                playerText2.classList.add(\"turn\");\n                \n                let shipSunk;\n                \n                if(playerTwo.gameboard.recieveAttack(x,y)){\n                    e.target.style.color = \"red\";\n                    e.target.style.borderColor = \"black\"\n                    \n                    for(const ship of playerTwo.gameboard.shipList){\n                        let shipCoords = ship.coordinateArray();\n                        for(const pair of shipCoords){\n                            if(parseInt(pair[0]) == x && parseInt(pair[1]) == y){\n                                shipSunk = ship.isSunk();\n                            }\n                        }\n                        console.log(shipCoords);\n                    }\n                }\n\n                if(shipSunk){\n                    announcement.innerHTML = \"Ship Has Been Sunk!\"\n                    shipSunk = !shipSunk;\n                }\n\n                else{\n                    announcement.innerHTML = \"\";\n                }\n\n\n                e.target.innerHTML = \"X\";\n\n                if(playerTwo.gameboard.allSink()){\n                    endGame(\"Player 1\");\n                }\n                console.log(e.target.getAttribute(\"horizontal\"));\n                console.log(e.target.getAttribute(\"vertical\"));\n            }\n            \n        }\n        \n    })\n})\n\nfunction endGame(player){\n\n    let screen = document.createElement(\"div\");\n    screen.classList.add(\"backScreen\");\n\n    let screenContent = document.createElement(\"div\");\n\n    screenContent.classList.add(\"end_screen\");\n\n    let text = document.createElement(\"h1\");\n\n    text.textContent = `${player} Won!`\n    let button =  document.createElement(\"button\");\n    button.textContent = \"Restart\"\n    button.classList.add(\"end_button\")\n    let body = document.getElementById(\"body\");\n\n    screenContent.appendChild(text);\n    screenContent.appendChild(button);\n    screen.appendChild(screenContent);\n    body.appendChild(screen);\n    button.addEventListener(\"click\", () => {\n        location.reload();\n    })\n}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JhdHRsZXNoaXAvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1BsYXllciwgU2hpcH0gZnJvbSBcIi4vYmF0dGxlLmpzXCJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcblxubGV0IHBsYXllck9uZSA9IG5ldyBQbGF5ZXIoKTtcbmxldCBwbGF5ZXJUd28gPSBuZXcgUGxheWVyKCk7XG5cbmxldCBjdXJyZW50SGlnaGxpZ2h0O1xubGV0IGN1cnJlbnRTaXplID0gMTtcbmxldCBjdXJyZW50RGlyZWN0aW9uO1xubGV0IHBsYWNlQWxsb3dlZDtcbmxldCBwbGFjZUxvY2F0aW9uO1xubGV0IHNoaXBOYW1lcyA9IFtcIkNhcnJpZXJcIiwgXCJCYXR0bGVzaGlwXCIsIFwiRGVzdHJveWVyXCIsIFwiU3VibWFyaW5lXCIgLFwiUGF0cm9sXCJdXG5cbmNvbnN0IGxlZnRTaWRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWZ0X3NpZGVcIik7XG5jb25zdCByaWdodFNpZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJpZ2h0X3NpZGVcIik7XG5sZXQgYW5ub3VuY2VtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhbm5vdW5jZW1lbnRcIik7XG5cbmFubm91bmNlbWVudC50ZXh0Q29udGVudCA9IFwiQXJyYW5nZSB5b3VyIHNoaXBzIVwiXG5cblxuZnVsbHlSZW5kZXJTaWRlKGxlZnRTaWRlLCBwbGF5ZXJPbmUpO1xuZnVsbHlSZW5kZXJTaWRlKHJpZ2h0U2lkZSwgcGxheWVyVHdvKTtcblxubGV0IGN1cnJlbnRJZDtcblxuXG5mdW5jdGlvbiBhZGRHcmlkQm94ZXMoc2lkZSxjb29yZHMpe1xuICAgIFxuICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gMTA7IGkrKyl7XG4gICAgICAgIGZvcihsZXQgaiA9IDE7IGogPD0gMTA7IGorKyl7XG4gICAgICAgICAgICBpZihjaGVja1BhaXIoaSxqLGNvb3JkcykgPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgIGxldCBncmlkQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBncmlkQm94LmNsYXNzTGlzdC5hZGQoXCJncmlkQm94XCIpO1xuICAgICAgICAgICAgICAgIGdyaWRCb3guc2V0QXR0cmlidXRlKFwiaG9yaXpvbnRhbFwiLCBgJHtpfWApO1xuICAgICAgICAgICAgICAgIGdyaWRCb3guc2V0QXR0cmlidXRlKFwidmVydGljYWxcIiwgYCR7an1gKTtcbiAgICAgICAgICAgICAgICBpZihzaWRlLmlkID09IFwibGVmdF9zaWRlXCIpe1xuICAgICAgICAgICAgICAgICAgICBncmlkQm94LmlkID0gYExzcXVhcmUkeyhpLTEpKiAxMCArIChqKX1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkQm94LmlkID0gYFJzcXVhcmUkeyhpLTEpKiAxMCArIChqKX1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGdyaWRCb3gudmVydGljYWwgPSBqO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2lkZS5hcHBlbmRDaGlsZChncmlkQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZ1bGx5UmVuZGVyU2lkZShzaWRlLCBwbGF5ZXIpe1xuICAgIHNpZGUuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBsZXQgc2hpcENvb3JkaW5hdGVzID0gcGxheWVyLmdhbWVib2FyZC5nZXRDb29yZGluYXRlTGlzdCgpO1xuICAgIFxuXG4gICAgbGV0IHJlc3RyaWN0ZWRTcXVhcmVzID0gbWFrZVJlc3RyaWN0ZWRTcXVhcmVzTGlzdChzaGlwQ29vcmRpbmF0ZXMpO1xuICAgIGFkZEdyaWRCb3hlcyhzaWRlLHNoaXBDb29yZGluYXRlcylcbiAgICByZW5kZXJHcmlkKHNpZGUsIHBsYXllciwgcmVzdHJpY3RlZFNxdWFyZXMpXG59XG5cblxuZnVuY3Rpb24gY2hlY2tQYWlyKHgseSwgc2hpcENvb3JkaW5hdGVzKXtcbiAgICBmb3IoY29uc3QgcGFpciBvZiBzaGlwQ29vcmRpbmF0ZXMpe1xuICAgICAgICBpZihwYWlyWzBdID09IHggJiYgcGFpclsxXSA9PSB5KXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZXN0cmljdGVkU3F1YXJlc0xpc3QoY29vcmRMaXN0KXtcblxuICAgIGxldCByZXN0cmljdGVkU3F1YXJlcyA9IFtdO1xuICAgIGZvcihjb25zdCBwYWlyIG9mIGNvb3JkTGlzdCl7XG4gICAgICAgIGxldCB4ID0gcGFyc2VJbnQocGFpclswXSk7XG4gICAgICAgIGxldCB5ID0gcGFyc2VJbnQocGFpclsxXSk7XG5cbiAgICAgICAgbGV0IHNxdWFyZU51bSA9ICh4LTEpKjEwICsgeTtcbiAgICAgICAgcmVzdHJpY3RlZFNxdWFyZXMucHVzaChzcXVhcmVOdW0pO1xuXG4gICAgfVxuICAgIHJldHVybiByZXN0cmljdGVkU3F1YXJlcztcblxuICAgIC8vIGNvbnNvbGUubG9nKHJlc3RyaWN0ZWRTcXVhcmVzKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKClcbn1cbmZ1bmN0aW9uIGNsZWFyU3F1YXJlcygpe1xuICAgIGxldCBhbGxTcXVhcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ncmlkQm94XCIpO1xuICAgIGFsbFNxdWFyZXMuZm9yRWFjaCgoc3F1YXJlKSA9PiB7XG4gICAgICAgIHNxdWFyZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCI7XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tDb2xsaXNpb24oc3F1YXJlTnVtLCBob3Jpem9udGFsLCByZXN0cmljdGVkU3F1YXJlcyl7XG4gICAgbGV0IHNxdWFyZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNxdWFyZU51bSk7XG4gICAgXG4gICAgXG4gICAgY29uc29sZS5sb2coYHNxdWFyZU51bSBpbiBjb2xsaXNpb246ICR7c3F1YXJlTnVtfWApO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjdXJyZW50U2l6ZTsgaSsrKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYHNxdWFyZU51bStpOiAke3NxdWFyZU51bStpfWApO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgY3VycmVudFNpemUgaW4gY29sbGlzaW9uOiAke2N1cnJlbnRTaXplfWApXG5cbiAgICAgICAgaWYgKGhvcml6b250YWwgPT09IFwidHJ1ZVwiKXtcbiAgICAgICAgICAgIGlmKHJlc3RyaWN0ZWRTcXVhcmVzLmluY2x1ZGVzKHNxdWFyZU51bStpKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGlmKHJlc3RyaWN0ZWRTcXVhcmVzLmluY2x1ZGVzKHNxdWFyZU51bStpKjEwKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gICAgXG5cbiAgICBcbn1cbmZ1bmN0aW9uIHJlbmRlckdyaWQoc2lkZSwgcGxheWVyLCByZXN0cmljdGVkU3F1YXJlcyl7XG4gICAgY29uc3Qgc2hpcExpc3QgPSBwbGF5ZXIuZ2FtZWJvYXJkLnNoaXBMaXN0O1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgY29sb3JMaXN0ID0gW1wiZ3JheVwiLCBcImJsdWVcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIiwgXCJ5ZWxsb3dcIl07XG4gICAgXG4gICAgXG4gICAgbGV0IHNpZGVUZXh0O1xuICAgIGlmKHNpZGUuaWQgPT0gXCJsZWZ0X3NpZGVcIil7XG4gICAgICAgIHNpZGVUZXh0ID0gXCJMXCI7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHNpZGVUZXh0ID0gXCJSXCJcbiAgICB9XG4gICAgc2lkZS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGUpID0+IHtcbiAgICAgICAgXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gQWxsb3cgZHJvcFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGxldCBkcmFnU2hpcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGN1cnJlbnRJZCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgc2hpcFNpemUgPSBkcmFnU2hpcC5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpO1xuXG4gICAgICAgIGxldCBob3Jpem9udGFsID0gZHJhZ1NoaXAuZ2V0QXR0cmlidXRlKFwiaG9yaXpvbnRhbFwiKTtcblxuICAgICAgICBcbiAgICAgICAgY3VycmVudFNpemUgPSBwYXJzZUludChkcmFnU2hpcC5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpKTtcblxuXG5cbiAgICAgICAgbGV0IHByZXZpb3VzU3F1YXJlO1xuXG4gICAgICAgIGlmKGN1cnJlbnRIaWdobGlnaHQpe1xuICAgICAgICAgICAgcHJldmlvdXNTcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjdXJyZW50SGlnaGxpZ2h0KTtcbiAgICAgICAgICAgIGlmKGUudGFyZ2V0LmlkICE9IHByZXZpb3VzU3F1YXJlKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjbGVhclNxdWFyZXMoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgbGV0IHRhcmdldElkID0gZS50YXJnZXQuaWQ7XG5cbiAgICAgICAgY29uc29sZS5sb2coYGRyYWdTaGlwLmlkOiAke2RyYWdTaGlwLmlkfSBlLnRhcmdldC5pZFswXSR7ZS50YXJnZXQuaWRbMF19YCk7XG4gICAgICAgIGlmIChkcmFnU2hpcC5pZFswXSAhPSBlLnRhcmdldC5pZFswXSkge1xuICAgICAgICAgICAgcGxhY2VBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgLy8gU2tpcCBwcm9jZXNzaW5nIGZvciBlbGVtZW50cyBub3Qgd2l0aGluIHRoaXMgc2lkZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoKHNpZGUuY29udGFpbnMoZS50YXJnZXQpKSAmJiAhZS50YXJnZXQuaGFzQXR0cmlidXRlKFwic2l6ZVwiKSl7XG4gICAgICAgICAgICBjdXJyZW50SGlnaGxpZ2h0ID0gZS50YXJnZXQuaWQ7XG4gICAgICAgICAgICBsZXQgc3F1YXJlTnVtID0gcGFyc2VJbnQoZS50YXJnZXQuaWQubWF0Y2goL1xcZCsvKVswXSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBlLnRhcmdldC5pZDogJHtlLnRhcmdldC5pZH1gKTtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAvL2hvcml6b250YWwgY2hlY2tpbmdcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaG9yaXpvbnRhbCA9PT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgICAgIGlmKCgocGFyc2VJbnQoc3F1YXJlTnVtKSAtMSApJSAxMCkgKyBwYXJzZUludChjdXJyZW50U2l6ZSkgPiAxMCl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IHNxdWFyZU51bTsgaSA8PSBwYXJzZUludCgoc3F1YXJlTnVtLTEpLzEwKSoxMCArIDEwOyBpKysgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNxdWFyZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke3NpZGVUZXh0fXNxdWFyZSR7cGFyc2VJbnQoaSkgfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZUFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlTG9jYXRpb24gPSBzcXVhcmVOdW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9ubyBjb2xsaXNpb24gYW5kIG5vIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGNvbGxpc2lvbjogJHtjaGVja0NvbGxpc2lvbihzcXVhcmVOdW0sIGhvcml6b250YWwsIHJlc3RyaWN0ZWRTcXVhcmVzKX1gKVxuICAgICAgICAgICAgICAgICAgICBpZighY2hlY2tDb2xsaXNpb24oc3F1YXJlTnVtLCBob3Jpem9udGFsLCByZXN0cmljdGVkU3F1YXJlcykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRTaXplOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtzaWRlVGV4dH1zcXVhcmUke3BhcnNlSW50KHNxdWFyZU51bSkgKyBpIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJncmVlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VMb2NhdGlvbiA9IHNxdWFyZU51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2NvbGxpc2lvbiBjaGVjayBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudFNpemU7IGkrKyl7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXJlc3RyaWN0ZWRTcXVhcmVzLmluY2x1ZGVzKHNxdWFyZU51bStpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtzaWRlVGV4dH1zcXVhcmUke3BhcnNlSW50KHNxdWFyZU51bSkgKyBpIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZUxvY2F0aW9uID0gc3F1YXJlTnVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy92ZXJ0aWNhbCBjaGVja2luZ1xuICAgICAgICAgICAgZWxzZXtcblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgb3ZlcmZsb3cgdmVydGljYWxseVxuICAgICAgICAgICAgICAgIGlmKChzcXVhcmVOdW0tMTApICsgY3VycmVudFNpemUqMTAgPiAxMDApe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgc3F1YXJlTnVtICsgY3VycmVudFNpemUqMTA6JHtzcXVhcmVOdW0gKyBjdXJyZW50U2l6ZSoxMH1gKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gc3F1YXJlTnVtOyBpIDw9IDEwMDsgaSs9IDEwICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgc3F1YXJlTnVtICsgaTogJHtwYXJzZUludChpKSB9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtzaWRlVGV4dH1zcXVhcmUke3BhcnNlSW50KGkpIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBzcXVhcmVzZWNvbmRJZDogJHtzcXVhcmUuaWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VMb2NhdGlvbiA9IHNxdWFyZU51bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNvbGxpc2lvbiB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWNoZWNrQ29sbGlzaW9uKHNxdWFyZU51bSwgaG9yaXpvbnRhbCwgcmVzdHJpY3RlZFNxdWFyZXMpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRTaXplOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtzaWRlVGV4dH1zcXVhcmUke3BhcnNlSW50KHNxdWFyZU51bSkgKyBpKjEwIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJncmVlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VMb2NhdGlvbiA9IHNxdWFyZU51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudFNpemU7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXJlc3RyaWN0ZWRTcXVhcmVzLmluY2x1ZGVzKHNxdWFyZU51bStpKjEwKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtzaWRlVGV4dH1zcXVhcmUke3BhcnNlSW50KHNxdWFyZU51bSkgKyBpKjEwfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VMb2NhdGlvbiA9IHNxdWFyZU51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pXG5cbiAgICBzaWRlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImhvcml6b250YWxcIikpO1xuICAgICAgICBjb25zb2xlLmxvZyhlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ2ZXJ0aWNhbFwiKSk7XG4gICAgICAgIFxuICAgIH0pXG5cbiAgICBsZXQgc2hpcENvdW50ZXIgPSAwO1xuICAgIGZvcihjb25zdCBzaGlwIG9mIHNoaXBMaXN0KXtcbiAgICAgICAgbGV0IGNvb3JkaW5hdGVBcnJheSA9IHNoaXAuY29vcmRpbmF0ZUFycmF5KCk7XG4gICAgICAgIGxldCBjb29yZExlbmd0aCA9IGNvb3JkaW5hdGVBcnJheS5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgbGV0IGdyaWRTaGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGdyaWRTaGlwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yTGlzdFtjb3VudGVyXTtcbiAgICAgICAgICAgIGdyaWRTaGlwLnN0eWxlLmJvcmRlciA9IFwiM3B4IHNvbGlkXCJcbiAgICAgICAgICAgIGdyaWRTaGlwLnNldEF0dHJpYnV0ZShcInNpemVcIiwgc2hpcC5nZXRTaXplKCkpO1xuICAgICAgICAgICAgZ3JpZFNoaXAuaWQgPSBgJHtzaWRlVGV4dCsgc2hpcE5hbWVzW3NoaXBDb3VudGVyXX1gO1xuICAgICAgICAgICAgc2hpcENvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIGdyaWRTaGlwLnNldEF0dHJpYnV0ZShcImluZGV4XCIsIGNvdW50ZXIpXG4gICAgICAgICAgICBncmlkU2hpcC5zZXRBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAvL2hvcml6b250YWwgZGlyZWN0aW9uXG4gICAgICAgIFxuICAgICAgICAgICAgaWYoY29vcmRpbmF0ZUFycmF5WzBdWzBdID09IGNvb3JkaW5hdGVBcnJheVsxXVswXSl7XG4gICAgICAgICAgICAgICAgZ3JpZFNoaXAuc2V0QXR0cmlidXRlKFwiaG9yaXpvbnRhbFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImZpcnN0XCIpO1xuICAgICAgICAgICAgICAgIGdyaWRTaGlwLnN0eWxlLmdyaWRSb3cgPSBgJHtjb29yZGluYXRlQXJyYXlbMF1bMF19IC8gJHtjb29yZGluYXRlQXJyYXlbMF1bMF19YDtcbiAgICAgICAgICAgICAgICBncmlkU2hpcC5zdHlsZS5ncmlkQ29sdW1uID0gYCR7Y29vcmRpbmF0ZUFycmF5WzBdWzFdfSAvICR7Y29vcmRpbmF0ZUFycmF5W2Nvb3JkTGVuZ3RoLTFdWzFdICsgMX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBncmlkU2hpcC5zZXRBdHRyaWJ1dGUoXCJob3Jpem9udGFsXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBncmlkU2hpcC5zdHlsZS5ncmlkUm93ID0gYCR7Y29vcmRpbmF0ZUFycmF5WzBdWzBdfSAvICR7Y29vcmRpbmF0ZUFycmF5W2Nvb3JkTGVuZ3RoLTFdWzBdICsgMX1gO1xuICAgICAgICAgICAgICAgIGdyaWRTaGlwLnN0eWxlLmdyaWRDb2x1bW4gPSBgJHtjb29yZGluYXRlQXJyYXlbMF1bMV19IC8gJHtjb29yZGluYXRlQXJyYXlbMF1bMV19YDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jbGljayB0byBmbGlwIGRpcmVjdGlvblxuICAgICAgICAgICAgZ3JpZFNoaXAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChncmlkU2hpcC5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpKVxuICAgICAgICAgICAgICAgIGxldCBncmlkU2hpcFNxdWFyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgcGFpciBvZiBjb29yZGluYXRlQXJyYXkpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHBhcnNlSW50KHBhaXJbMF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHBhcnNlSW50KHBhaXJbMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyaWRTaGlwU3F1YXJlcy5wdXNoKCh4LTEpKjEwICsgeSApO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXN0cmljdGVkIFNxdWFyZXM6ICR7cmVzdHJpY3RlZFNxdWFyZXN9YClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgZ3JpZFNoaXBTcXVhcmVzOiAke2dyaWRTaGlwU3F1YXJlc31gKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjb29yZGluYXRlQXJyYXk6ICR7Y29vcmRpbmF0ZUFycmF5fWApXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IHNoaXBIb3Jpem9udGFsID0gZ3JpZFNoaXAuZ2V0QXR0cmlidXRlKFwiaG9yaXpvbnRhbFwiKTtcblxuICAgICAgICAgICAgICAgIC8vZmxpcCB0byBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgaWYoc2hpcEhvcml6b250YWwgPT0gXCJmYWxzZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gcGFyc2VJbnQoY29vcmRpbmF0ZUFycmF5W2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB5ID0gcGFyc2VJbnQoY29vcmRpbmF0ZUFycmF5W2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TnVtID0gKHgtMSkgKiAxMCArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd29ya2luZ051bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjdXJyZW50TnVtOiAke2N1cnJlbnROdW19YClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB5ICsgc2l6ZSAtIDE6ICR7eSArIHNpemUgLSAxfWApXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlzaW9uID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgY2FuIGZsaXAgdG8gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHkgKyBzaXplIC0gMSA8PSAxMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyBvdmVyZmxvdyB0byB0aGUgcmlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgc2l6ZTsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWdyaWRTaGlwU3F1YXJlcy5pbmNsdWRlcyhjdXJyZW50TnVtICsgaikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdHJpY3RlZFNxdWFyZXMuaW5jbHVkZXMoY3VycmVudE51bSArIGopKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjb2xsaXNpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXJTaGlwID0gbmV3IFNoaXAoeCx5LHgseStzaXplLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZ2FtZWJvYXJkLnNoaXBMaXN0W3BhcnNlSW50KGdyaWRTaGlwLmdldEF0dHJpYnV0ZShcImluZGV4XCIpKV0gPSBvdGhlclNoaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHlSZW5kZXJTaWRlKHNpZGUscGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnb3QgdG8gdGhlIGVuZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgbGVmdCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoeSAtIChzaXplIC0gMSkgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIG92ZXJmbG93IHRvIHRoZSBsZWZ0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHNpemU7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFncmlkU2hpcFNxdWFyZXMuaW5jbHVkZXMoY3VycmVudE51bSAtIGopKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3RyaWN0ZWRTcXVhcmVzLmluY2x1ZGVzKGN1cnJlbnROdW0gLSBqKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighY29sbGlzaW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyU2hpcCA9IG5ldyBTaGlwKHgseSAtIHNpemUrMSx4LHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZ2FtZWJvYXJkLnNoaXBMaXN0W3BhcnNlSW50KGdyaWRTaGlwLmdldEF0dHJpYnV0ZShcImluZGV4XCIpKV0gPSBvdGhlclNoaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHlSZW5kZXJTaWRlKHNpZGUscGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnb3QgdG8gdGhlIGVuZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9mbGlwIHRvIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJob3Jpem9udGFsXCIpXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHBhcnNlSW50KGNvb3JkaW5hdGVBcnJheVtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHBhcnNlSW50KGNvb3JkaW5hdGVBcnJheVtpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudE51bSA9ICh4LTEpICogMTAgKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdvcmtpbmdOdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgY3VycmVudE51bTogJHtjdXJyZW50TnVtfWApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgeCAtIHNpemU6ICR7eCAtIHNpemV9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2xsaXNpb24gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBjYW4gZmxpcCB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoeCAtIHNpemUgPj0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyBvdmVyZmxvdyB1cFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgY3VycmVudE51bSArIGoqMTA6ICR7Y3VycmVudE51bSArIGoqMTB9YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWdyaWRTaGlwU3F1YXJlcy5pbmNsdWRlcyhjdXJyZW50TnVtIC0gaioxMCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdHJpY3RlZFNxdWFyZXMuaW5jbHVkZXMoY3VycmVudE51bSAtIGoqMTApKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjb2xsaXNpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXJTaGlwID0gbmV3IFNoaXAoeCAtIHNpemUgKzEseSx4LHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZ2FtZWJvYXJkLnNoaXBMaXN0W3BhcnNlSW50KGdyaWRTaGlwLmdldEF0dHJpYnV0ZShcImluZGV4XCIpKV0gPSBvdGhlclNoaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHlSZW5kZXJTaWRlKHNpZGUscGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnb3QgdG8gdGhlIGVuZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgY2FuIGZsaXAgZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih4ICsgc2l6ZSA8PSAxMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyBvdmVyZmxvdyB0byB0aGUgZG93blwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZ3JpZFNoaXBTcXVhcmVzLmluY2x1ZGVzKGN1cnJlbnROdW0gKyBqKjEwKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN0cmljdGVkU3F1YXJlcy5pbmNsdWRlcyhjdXJyZW50TnVtICsgaioxMCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNvbGxpc2lvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdGhlclNoaXAgPSBuZXcgU2hpcCh4LHkseCtzaXplLTEseSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5nYW1lYm9hcmQuc2hpcExpc3RbcGFyc2VJbnQoZ3JpZFNoaXAuZ2V0QXR0cmlidXRlKFwiaW5kZXhcIikpXSA9IG90aGVyU2hpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxseVJlbmRlclNpZGUoc2lkZSxwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdvdCB0byB0aGUgZW5kXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgZ3JpZFNoaXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJZCA9IGUudGFyZ2V0LmlkO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBncmlkU2hpcC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyU3F1YXJlcygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBsZWZ0IGF0OiAke2UudGFyZ2V0LmlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBsYXN0TG9jYXRpb246ICR7cGxhY2VMb2NhdGlvbn1gKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgYWxsb3dlZDogJHtwbGFjZUFsbG93ZWR9YClcblxuICAgICAgICAgICAgICAgIGlmKHBsYWNlQWxsb3dlZCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWxsb3dlZCB0cnVlXCIpXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS50YXJnZXQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTcXVhcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtzaWRlVGV4dH1zcXVhcmUke3BsYWNlTG9jYXRpb259YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByb3cgPSBwYXJzZUludChjdXJyZW50U3F1YXJlLmdldEF0dHJpYnV0ZShcImhvcml6b250YWxcIikpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1uID0gcGFyc2VJbnQoY3VycmVudFNxdWFyZS5nZXRBdHRyaWJ1dGUoXCJ2ZXJ0aWNhbFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBob3Jpem9udGFsID0gc2hpcC5nZXRBdHRyaWJ1dGUoXCJob3Jpem9udGFsXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyU2hpcDtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGhvcml6b250YWwgPT0gXCJ0cnVlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJTaGlwID0gbmV3IFNoaXAocm93LGNvbHVtbixyb3csY29sdW1uICsgY3VycmVudFNpemUgLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlclNoaXAgPSBuZXcgU2hpcChyb3csY29sdW1uLHJvdyArIGN1cnJlbnRTaXplIC0xLGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5nYW1lYm9hcmQuc2hpcExpc3RbcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoXCJpbmRleFwiKSldID0gb3RoZXJTaGlwO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVsbHlSZW5kZXJTaWRlKHNpZGUscGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBzaWRlLmFwcGVuZENoaWxkKGdyaWRTaGlwKTtcblxuICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgIH1cbn1cblxubGV0IGxlZnRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlZnRfYnV0dG9uXCIpO1xubGV0IHJpZ2h0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyaWdodF9idXR0b25cIik7XG5cbmxldCBsZWZ0UmVhZHkgPSBmYWxzZTtcbmxldCByaWdodFJlYWR5ID0gZmFsc2U7XG5cbmxldCBzdGFydEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnRfYnV0dG9uXCIpO1xuXG5cblxubGVmdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT57XG4gICAgaWYoIWxlZnRSZWFkeSl7XG4gICAgICAgIGxlZnRTaWRlLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIGxlZnRTaWRlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiZ3JheVwiO1xuICAgICAgICBsZWZ0QnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiZ3JheVwiO1xuICAgICAgICBsZWZ0UmVhZHkgPSAhbGVmdFJlYWR5O1xuICAgIH1cblxuICAgIGVsc2V7XG4gICAgICAgIGxlZnRTaWRlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgbGVmdEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImFxdWFcIjtcbiAgICAgICAgbGVmdFJlYWR5ID0gIWxlZnRSZWFkeTtcbiAgICAgICAgZnVsbHlSZW5kZXJTaWRlKGxlZnRTaWRlLCBwbGF5ZXJPbmUpXG4gICAgfVxuXG4gICAgaWYobGVmdFJlYWR5ICYmIHJpZ2h0UmVhZHkpe1xuICAgICAgICBzdGFydEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIlxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBzdGFydEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgICB9XG59KVxuXG5yaWdodEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT57XG4gICAgaWYoIXJpZ2h0UmVhZHkpe1xuICAgICAgICByaWdodFNpZGUuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgcmlnaHRTaWRlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiZ3JheVwiO1xuICAgICAgICByaWdodEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImdyYXlcIjtcbiAgICAgICAgcmlnaHRSZWFkeSA9ICFyaWdodFJlYWR5O1xuICAgIH1cblxuICAgIGVsc2V7XG4gICAgICAgIHJpZ2h0U2lkZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgcmlnaHRCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJhcXVhXCI7XG4gICAgICAgIHJpZ2h0UmVhZHkgPSAhcmlnaHRSZWFkeTtcbiAgICAgICAgZnVsbHlSZW5kZXJTaWRlKHJpZ2h0U2lkZSwgcGxheWVyVHdvKVxuICAgIH1cblxuICAgIGlmKGxlZnRSZWFkeSAmJiByaWdodFJlYWR5KXtcbiAgICAgICAgc3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCJcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgc3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgfVxufSlcblxuXG5zdGFydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgIGFubm91bmNlbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgY29uc3QgbmV3TGVmdCA9IGxlZnRTaWRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICBsZWZ0U2lkZS5yZXBsYWNlV2l0aChuZXdMZWZ0KTtcblxuICAgIGNvbnN0IG5ld1JpZ2h0ID0gcmlnaHRTaWRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICByaWdodFNpZGUucmVwbGFjZVdpdGgobmV3UmlnaHQpO1xuICAgIG5ld0xlZnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBuZXdSaWdodC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgbmV3TGVmdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgbmV3UmlnaHQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXG4gICAgbGVmdEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgcmlnaHRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHN0YXJ0QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuXG4gICAgYWRkR3JpZEJveGVzKG5ld0xlZnQsIFtdKTtcbiAgICBhZGRHcmlkQm94ZXMobmV3UmlnaHQsIFtdKTtcblxuXG4gICAgbGV0IGxlZnRUdXJuID0gdHJ1ZTtcbiAgICBsZXQgcmlnaHRUdXJuID0gZmFsc2U7XG5cbiAgICBsZXQgcGxheWVyVGV4dDEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsYXllclRleHQxXCIpO1xuICAgIGxldCBwbGF5ZXJUZXh0MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxheWVyVGV4dDJcIik7XG5cbiAgICBwbGF5ZXJUZXh0MS5jbGFzc0xpc3QuYWRkKFwidHVyblwiKTtcblxuXG5cbiAgICBuZXdMZWZ0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBpZiAocmlnaHRUdXJuICYmIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImdyaWRCb3hcIikpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgeCA9IHBhcnNlSW50KGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImhvcml6b250YWxcIikpO1xuICAgICAgICAgICAgbGV0IHkgPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ2ZXJ0aWNhbFwiKSk7XG4gICAgICAgICAgICBsZXQgYXR0YWNrTGlzdCA9IHBsYXllck9uZS5nYW1lYm9hcmQuYXR0YWNrTGlzdDtcbiAgICAgICAgICAgIGlmKCFjaGVja1BhaXIoeCx5LGF0dGFja0xpc3QpKXtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgbGVmdFR1cm4gPSAhbGVmdFR1cm47XG4gICAgICAgICAgICAgICAgcmlnaHRUdXJuID0gIXJpZ2h0VHVybjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwbGF5ZXJUZXh0Mi5jbGFzc0xpc3QucmVtb3ZlKFwidHVyblwiKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXJUZXh0MS5jbGFzc0xpc3QuYWRkKFwidHVyblwiKTtcbiAgICAgICAgICAgICAgICBsZXQgc2hpcFN1bms7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYocGxheWVyT25lLmdhbWVib2FyZC5yZWNpZXZlQXR0YWNrKHgseSkpe1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlckNvbG9yID0gXCJibGFja1wiXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IoY29uc3Qgc2hpcCBvZiBwbGF5ZXJPbmUuZ2FtZWJvYXJkLnNoaXBMaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaGlwQ29vcmRzID0gc2hpcC5jb29yZGluYXRlQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihjb25zdCBwYWlyIG9mIHNoaXBDb29yZHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcnNlSW50KHBhaXJbMF0pID09IHggJiYgcGFyc2VJbnQocGFpclsxXSkgPT0geSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaXBTdW5rID0gc2hpcC5pc1N1bmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzaGlwQ29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHNoaXBTdW5rKXtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3VuY2VtZW50LmlubmVySFRNTCA9IFwiU2hpcCBIYXMgQmVlbiBTdW5rIVwiXG4gICAgICAgICAgICAgICAgICAgIHNoaXBTdW5rID0gIXNoaXBTdW5rO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGFubm91bmNlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuaW5uZXJIVE1MID0gXCJYXCI7XG5cbiAgICAgICAgICAgICAgICBpZihwbGF5ZXJPbmUuZ2FtZWJvYXJkLmFsbFNpbmsoKSl7XG4gICAgICAgICAgICAgICAgICAgIGVuZEdhbWUoXCJQbGF5ZXIgMlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaG9yaXpvbnRhbFwiKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwidmVydGljYWxcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSlcbiAgICBcbiAgICBuZXdSaWdodC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKGxlZnRUdXJuICYmIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImdyaWRCb3hcIikpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB4ID0gcGFyc2VJbnQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaG9yaXpvbnRhbFwiKSk7XG4gICAgICAgICAgICBsZXQgeSA9IHBhcnNlSW50KGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInZlcnRpY2FsXCIpKTtcbiAgICAgICAgICAgIGxldCBhdHRhY2tMaXN0ID0gcGxheWVyVHdvLmdhbWVib2FyZC5hdHRhY2tMaXN0O1xuICAgICAgICAgICAgaWYoIWNoZWNrUGFpcih4LHksYXR0YWNrTGlzdCkpe1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBsZWZ0VHVybiA9ICFsZWZ0VHVybjtcbiAgICAgICAgICAgICAgICByaWdodFR1cm4gPSAhcmlnaHRUdXJuO1xuXG4gICAgICAgICAgICAgICAgcGxheWVyVGV4dDEuY2xhc3NMaXN0LnJlbW92ZShcInR1cm5cIik7XG4gICAgICAgICAgICAgICAgcGxheWVyVGV4dDIuY2xhc3NMaXN0LmFkZChcInR1cm5cIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IHNoaXBTdW5rO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHBsYXllclR3by5nYW1lYm9hcmQucmVjaWV2ZUF0dGFjayh4LHkpKXtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJDb2xvciA9IFwiYmxhY2tcIlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IHNoaXAgb2YgcGxheWVyVHdvLmdhbWVib2FyZC5zaGlwTGlzdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2hpcENvb3JkcyA9IHNoaXAuY29vcmRpbmF0ZUFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoY29uc3QgcGFpciBvZiBzaGlwQ29vcmRzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJzZUludChwYWlyWzBdKSA9PSB4ICYmIHBhcnNlSW50KHBhaXJbMV0pID09IHkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlwU3VuayA9IHNoaXAuaXNTdW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc2hpcENvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihzaGlwU3Vuayl7XG4gICAgICAgICAgICAgICAgICAgIGFubm91bmNlbWVudC5pbm5lckhUTUwgPSBcIlNoaXAgSGFzIEJlZW4gU3VuayFcIlxuICAgICAgICAgICAgICAgICAgICBzaGlwU3VuayA9ICFzaGlwU3VuaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBhbm5vdW5jZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmlubmVySFRNTCA9IFwiWFwiO1xuXG4gICAgICAgICAgICAgICAgaWYocGxheWVyVHdvLmdhbWVib2FyZC5hbGxTaW5rKCkpe1xuICAgICAgICAgICAgICAgICAgICBlbmRHYW1lKFwiUGxheWVyIDFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImhvcml6b250YWxcIikpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInZlcnRpY2FsXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pXG59KVxuXG5mdW5jdGlvbiBlbmRHYW1lKHBsYXllcil7XG5cbiAgICBsZXQgc2NyZWVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzY3JlZW4uY2xhc3NMaXN0LmFkZChcImJhY2tTY3JlZW5cIik7XG5cbiAgICBsZXQgc2NyZWVuQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICBzY3JlZW5Db250ZW50LmNsYXNzTGlzdC5hZGQoXCJlbmRfc2NyZWVuXCIpO1xuXG4gICAgbGV0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDFcIik7XG5cbiAgICB0ZXh0LnRleHRDb250ZW50ID0gYCR7cGxheWVyfSBXb24hYFxuICAgIGxldCBidXR0b24gPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24udGV4dENvbnRlbnQgPSBcIlJlc3RhcnRcIlxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZW5kX2J1dHRvblwiKVxuICAgIGxldCBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJib2R5XCIpO1xuXG4gICAgc2NyZWVuQ29udGVudC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICBzY3JlZW5Db250ZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgc2NyZWVuLmFwcGVuZENoaWxkKHNjcmVlbkNvbnRlbnQpO1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQoc2NyZWVuKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSlcbn1cbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;